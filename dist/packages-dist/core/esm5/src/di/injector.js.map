{"version":3,"sources":["../../../../../../packages/core/src/di/injector.ts"],"names":[],"mappings":"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","file":"injector.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nconst /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();\nexport const /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nclass _NullInjector implements Injector {\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n/**\n * \\@whatItDoes Injector interface\n * \\@howToUse \n * ```\n * const injector: Injector = ...;\n * injector.get(...);\n * ```\n * \n * \\@description \n * For more details, see the {\\@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * `Injector` returns itself when given `Injector` as a token:\n * {\\@example core/di/ts/injector_spec.ts region='injectInjector'}\n * \n * \\@stable\n * @abstract\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new _NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * If not found:\n   * - Throws an error if no `notFoundValue` that is not equal to\n   * Injector.THROW_IF_NOT_FOUND is given\n   * - Returns the `notFoundValue` otherwise\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n/**\n * Create a new Injector which is configure using `StaticProvider`s.\n * \n * ### Example\n * \n * {\\@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic create(providers: StaticProvider[], parent?: Injector): Injector {\n    return new StaticInjector(providers, parent);\n  }\n}\n\nfunction Injector_tsickle_Closure_declarations() {\n/** @type {?} */\nInjector.THROW_IF_NOT_FOUND;\n/** @type {?} */\nInjector.NULL;\n\n/**\n * Retrieves an instance from the injector based on the provided token.\n * If not found:\n * - Throws an error if no `notFoundValue` that is not equal to\n * Injector.THROW_IF_NOT_FOUND is given\n * - Returns the `notFoundValue` otherwise\n * @abstract\n * @template T\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nInjector.prototype.get = function(token, notFoundValue) {};\n\n/**\n * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n * @suppress {duplicate}\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nInjector.prototype.get = function(token, notFoundValue) {};\n}\n\n\n\n\nconst /** @type {?} */ IDENT = function<T>(value: T): T {\n  return value;\n};\nconst /** @type {?} */ EMPTY = /** @type {?} */(( <any[]>[]));\nconst /** @type {?} */ CIRCULAR = IDENT;\nconst /** @type {?} */ MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nconst /** @type {?} */ GET_PROPERTY_NAME = /** @type {?} */(( {} as any));\nconst /** @type {?} */ USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: GET_PROPERTY_NAME});\nconst /** @type {?} */ NG_TOKEN_PATH = 'ngTokenPath';\nconst /** @type {?} */ NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst /** @type {?} */ NULL_INJECTOR = Injector.NULL;\nconst /** @type {?} */ NEW_LINE = /\\n/gm;\nconst /** @type {?} */ NO_NEW_LINE = 'Éµ';\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\nprivate _records: Map<any, Record>;\n/**\n * @param {?} providers\n * @param {?=} parent\n */\nconstructor(providers: StaticProvider[], parent: Injector = NULL_INJECTOR) {\n    this.parent = parent;\n    const /** @type {?} */ records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, /** @type {?} */(( <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false})));\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T): T;\n  get(token: any, notFoundValue?: any): any;\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any): any {\n    const /** @type {?} */ record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue);\n    } catch ( /** @type {?} */e) {\n      const /** @type {?} */ tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      e.message = formatError('\\n' + e.message, tokenPath);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n/**\n * @return {?}\n */\ntoString() {\n    const /** @type {?} */ tokens = /** @type {?} */(( <string[]>[])), /** @type {?} */ records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\nfunction StaticInjector_tsickle_Closure_declarations() {\n/** @type {?} */\nStaticInjector.prototype.parent;\n/** @type {?} */\nStaticInjector.prototype._records;\n}\n\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n/**\n * @record\n */\nfunction Record() {}\n\n\nfunction Record_tsickle_Closure_declarations() {\n/** @type {?} */\nRecord.prototype.fn;\n/** @type {?} */\nRecord.prototype.useNew;\n/** @type {?} */\nRecord.prototype.deps;\n/** @type {?} */\nRecord.prototype.value;\n}\n\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n/**\n * @record\n */\nfunction DependencyRecord() {}\n\n\nfunction DependencyRecord_tsickle_Closure_declarations() {\n/** @type {?} */\nDependencyRecord.prototype.token;\n/** @type {?} */\nDependencyRecord.prototype.options;\n}\n\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n/**\n * @param {?} provider\n * @return {?}\n */\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const /** @type {?} */ deps = computeDeps(provider);\n  let /** @type {?} */ fn: Function = IDENT;\n  let /** @type {?} */ value: any = EMPTY;\n  let /** @type {?} */ useNew: boolean = false;\n  let /** @type {?} */ provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = ( /** @type {?} */((provider as ValueProvider))).useValue;\n  } else if (( /** @type {?} */((provider as FactoryProvider))).useFactory) {\n    fn = ( /** @type {?} */((provider as FactoryProvider))).useFactory;\n  } else if (( /** @type {?} */((provider as ExistingProvider))).useExisting) {\n    // Just use IDENT\n  } else if (( /** @type {?} */((provider as StaticClassProvider))).useClass) {\n    useNew = true;\n    fn = resolveForwardRef(( /** @type {?} */((provider as StaticClassProvider))).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n/**\n * @param {?} records\n * @param {?} provider\n * @return {?}\n */\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let /** @type {?} */ i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let /** @type {?} */ token = resolveForwardRef(provider.provide);\n      const /** @type {?} */ resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let /** @type {?} */ multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = /** @type {?} */(( <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          })));\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const /** @type {?} */ record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n/**\n * @param {?} token\n * @param {?} record\n * @param {?} records\n * @param {?} parent\n * @param {?} notFoundValue\n * @return {?}\n */\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue);\n  } catch ( /** @type {?} */e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const /** @type {?} */ path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n/**\n * @param {?} token\n * @param {?} record\n * @param {?} records\n * @param {?} parent\n * @param {?} notFoundValue\n * @return {?}\n */\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any): any {\n  let /** @type {?} */ value;\n  if (record) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let /** @type {?} */ obj = undefined;\n      let /** @type {?} */ useNew = record.useNew;\n      let /** @type {?} */ fn = record.fn;\n      let /** @type {?} */ depRecords = record.deps;\n      let /** @type {?} */ deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let /** @type {?} */ i = 0; i < depRecords.length; i++) {\n          const /** @type {?} */ depRecord: DependencyRecord = depRecords[i];\n          const /** @type {?} */ options = depRecord.options;\n          const /** @type {?} */ childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND));\n        }\n      }\n      record.value = value = useNew ? new ( /** @type {?} */((fn as any)))(...deps) : fn.apply(obj, deps);\n    }\n  } else {\n    value = parent.get(token, notFoundValue);\n  }\n  return value;\n}\n/**\n * @param {?} provider\n * @return {?}\n */\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let /** @type {?} */ deps: DependencyRecord[] = EMPTY;\n  const /** @type {?} */ providerDeps: any[] =\n      ( /** @type {?} */((provider as ExistingProvider & StaticClassProvider & ConstructorProvider))).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let /** @type {?} */ i = 0; i < providerDeps.length; i++) {\n      let /** @type {?} */ options = OptionFlags.Default;\n      let /** @type {?} */ token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let /** @type {?} */ j = 0, /** @type {?} */ annotations = token; j < annotations.length; j++) {\n          const /** @type {?} */ annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = ( /** @type {?} */((annotation as Inject))).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if (( /** @type {?} */((provider as ExistingProvider))).useExisting) {\n    const /** @type {?} */ token = resolveForwardRef(( /** @type {?} */((provider as ExistingProvider))).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n/**\n * @param {?} text\n * @param {?} obj\n * @return {?}\n */\nfunction formatError(text: string, obj: any): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let /** @type {?} */ context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let /** @type {?} */ parts = /** @type {?} */(( <string[]>[]));\n    for (let /** @type {?} */ key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let /** @type {?} */ value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n/**\n * @param {?} text\n * @param {?} obj\n * @return {?}\n */\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n/**\n * @template T\n * @param {?} objWithPropertyToExtract\n * @return {?}\n */\nfunction getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let /** @type {?} */ key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === GET_PROPERTY_NAME) {\n      return key;\n    }\n  }\n  throw Error('!prop');\n}\n"]}